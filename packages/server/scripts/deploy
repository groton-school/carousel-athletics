#!/usr/bin/env node

import gcloud from '@battis/partly-gcloudy';
import { confirm, input, select } from '@inquirer/prompts';
import { Colors } from '@qui-cli/colors';
import { Core } from '@qui-cli/core';
import { Env } from '@qui-cli/env-1password';
import { Log } from '@qui-cli/log';
import * as Plugin from '@qui-cli/plugin';
import { Shell } from '@qui-cli/shell';
import { Validators } from '@qui-cli/validators';
import path from 'node:path';

/*
type RedisInstance = {
  authorizedNetwork: string,
  availableMaintenanceVersions: string[
   
  ],
  connectMode: string,
  createTime: DateTimeString,
  currentLocationId: string,
  host: string,
  locationId: string,
  maintenanceVersion: string,
  memorySizeGb: number,
  name: string,
  nodes: 
    {
      id: string,
      zone: string
    }[]
  ,
  persistenceConfig: {
    persistenceMode: string
  },
  persistenceIamIdentity: string,
  port:number,
  readReplicasMode: string,
  redisVersion: string,
  reservedIpRange: string,
  state: string,
  tier: string,
  transitEncryptionMode: string
}
  */

let setup = false;
let name = 'Carousel - Athletics';
let billing = undefined;
let region = undefined;
let supportEmail = undefined;
let accessKey = undefined;
let clientId = undefined;
let clientSecret = undefined;

function configure(config = {}) {
  setup = Plugin.hydrate(config.force, !process.env.PROJECT);
  name = Plugin.hydrate(config.name, name);
  billing = Plugin.hydrate(config.billing, billing);
  region = Plugin.hydrate(config.region, region);
  supportEmail = Plugin.hydrate(config.supportEmail, supportEmail);
  accessKey = Plugin.hydrate(config.accessKey, accessKey);
  clientId = Plugin.hydrate(config.clientId, clientId);
  clientSecret = Plugin.hydrate(config.clientSecret, clientSecret);
}

function options() {
  return {
    opt: {
      name: {
        description: 'Google Cloud project name',
        default: name
      },
      billing: {
        description: 'Google Cloud billing account ID for this project'
      },
      region: {
        description:
          'Google Cloud region in which to create App Engine instance'
      },
      supportEmail: {
        description: 'Support email address for app OAuth consent screen'
      },
      accessKey: {
        description: 'Blackbaud SKY API subscription access key',
        url: 'https://developer.blackbaud.com/subscriptions'
      },
      clientId: {
        description: 'Blackbaud SKY API app OAuth client ID',
        url: 'https://developer.blackbaud.com/apps'
      },
      clientSecret: {
        description: 'Blackbaud SKY API app OAuth client secret'
      }
    },
    flag: {
      force: {
        description: `Force run initial setup script (normally skipped if ${Colors.url('.env')} is configured)`,
        short: 'f'
      }
    }
  };
}

async function guideBlackbaudAppCreation({
  hostname,
  accessKey: access_key = undefined,
  clientId: client_id = undefined,
  clientSecret: client_secret = undefined
}) {
  access_key = await input({
    message: `${options().opt.accessKey.description} from ${Colors.url(
      'https://developer.blackbaud.com/subscriptions'
    )}`,
    validate: Validators.notEmpty,
    default: access_key
  });
  await confirm({
    message: `Create a new app at ${Colors.url('https://developer.blackbaud.com/apps')}`
  });
  client_id = await input({
    message: options().opt.clientId.description,
    validate: Validators.notEmpty,
    default: client_id
  });
  client_secret = await input({
    message: options().opt.clientSecret.description,
    validate: Validators.notEmpty,
    default: client_secret
  });
  const redirect_uri = `https://${hostname}/redirect`;
  await confirm({
    message: `Configure ${Colors.value(redirect_uri)} as the app's redirect URL`
  });
  await confirm({
    message: `Limit the SKY API scopes as described at ${Colors.url(
      'https://github.com/groton-school/blackbaud-to-google-group-sync/blob/main/docs/blackbaud-api-scope.md'
    )}`
  });
  return { access_key, client_id, client_secret, redirect_uri };
}

function init(args) {
  configure(args.values);
}

async function run() {
  let projectId = await Env.get({ key: 'PROJECT' });
  let region = await Env.get({ key: 'REGION' });
  let email = await Env.get({ key: 'IDENTITY' });

  if (setup) {
    const project = await gcloud.projects.create({
      projectId
    });
    projectId = project.projectId;
    await Env.set({ key: 'PROJECT', value: projectId });
    region = await select({
      message: 'Which region would you like to deploy to?',
      default: region,
      choices: JSON.parse(
        Shell.exec(
          `gcloud run regions list --project=${projectId} --format=json`
        ).stdout
      ).map((r) => ({
        name: `${r.locationId} (${r.displayName})`,
        value: r.locationId
      }))
    });
    await gcloud.services.enable(gcloud.services.API.CloudRunAdminAPI);
    await gcloud.services.enable(gcloud.services.API.ArtifactRegistryAPI);

    let identity;
    if (email) {
      identity = await gcloud.iam.serviceAccounts.describe({ email });
    } else {
      identity = await gcloud.iam.serviceAccounts.create({
        displayName: await input({
          message: 'Service Account display name',
          default: 'Cloud Run Service Identity',
          validate: Validators.notEmpty
        }),
        name: await input({
          message: 'Service Account name',
          default: 'cloud-run',
          validate: Validators.notEmpty
        })
      });
    }
    email = identity.email;
    Env.set({ key: 'IDENTITY', value: email });
    await gcloud.iam.addPolicyBinding({
      user: email,
      userType: 'serviceAccount',
      role: gcloud.iam.Role.SecretManager.SecretAccessor
    });
    await gcloud.iam.addPolicyBinding({
      user: email,
      userType: 'serviceAccount',
      role: 'roles/secretmanager.secretVersionManager'
    });
  }
  try {
    const app = JSON.parse(
      Shell.exec(
        `gcloud run deploy athletics --source dist --service-account=${
          email
        } --region=${
          region
        } --set-env-vars="GOOGLE_CLOUD_PROJECT=${projectId}" --allow-unauthenticated --base-image=nodejs22 --automatic-updates --project=${projectId} --format=json`
      ).stdout
    );
    Log.info(
      `${app.kind} ${Colors.value(app.metadata.name)} deployed to ${Colors.url(app.status.url)}`
    );
    if (setup) {
      const blackbaud = await guideBlackbaudAppCreation({
        hostname: new URL(app.status.url).hostname,
        accessKey,
        clientId,
        clientSecret
      });
      await gcloud.secrets.set({ name: 'BLACKBAUD', value: blackbaud });
    }
  } catch (error) {
    Log.error(Colors.error(`Deploy failed.`));
    process.exit(1);
  }
}

await Plugin.register({
  name: 'deploy',
  src: path.resolve(path.dirname(import.meta.dirname), 'src'),
  options,
  init,
  run
});
await Core.run();
